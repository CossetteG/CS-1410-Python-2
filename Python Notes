ok python notes will go here

Review: 

string: "word" or 'words' or """lots
    of words"""
int: whole number
float: real number
bool: True or False




file: with open("filename.py", "r,w,a"):
    do stuff with the file: readline, writeline, for loop

list: ["ordered", "mutable",]
tuples: ("immutable", "ordered")
sets: {"unordered", "mutable", "does not allow duplicates}
dict: {"key": "value", "very": "fun", "unordered": "and mutable"} 
    aka lookup table,  hashtable, map

append: adds to the end of a list
_.append("element")
extend: adds a list to the end of another list
_.extend(other list) or you can add with +
insert: inserts and element in a specific place in a list
_.insert(index, element)
pop: _.pop() or _.pop(index) returns the value that is removed from the list
in: checks if something is in a list, returns true or false
for n in (): ..... if n in (): 
index: returns an elements position or an error if not found
_.index(n) 
sort: will rearrange a list to be in alphabetical order, must be one data type
_.sort() will return None and then sort the original list
sorted(): kinda the same as sort but better for creating new lists
sorted(_, key=_) 
remove: removes the first instance of it from a list 
_.remove("element")

^most are illegal for immutables: tuples, sets, dict
finding things in a dict: find by key only 
dict_name["key"]
get: finding things but with a default value in case it isnt there 
dict_name.get(key, default_value)
pop: for dict- input is the key, return is the value, and it will be deleted
pop(key, default=) default is optional in case its not there
to print all the values: for key in dict_name: print key, grades[key]
return key-value pairs: list(dict_name.items())
return keys: list(dict_name.keys())
return values: list(dict_name.values())
len: finds the length of an iterable, starts the count at 1
len(iterable)
clear: removes all the keys in a dict idk
adding to a dict with a loop: dict_name[key] = value
    dict_name.get(key, default value) + 1 #counts how many of that key is in the original list

Sets are like dicts but keys and values are 1 and allows set operations and no duplicates
Union: |, intersection &, and difference -- 
x,y = {'a','b','c'}, {'c','d','e’}
print(x | y)
{'d', 'e', 'b', 'c', 'a’}
print(x & y)
{'c’}
print(x – y)
{'a', 'b’}
print(y – x)
{'e', 'd’}
x |= {'f',’g’}
print(x)
{'f', 'g', 'b', 'c', 'a'}


split: takes every word in a string and turns it into a list of words
s.split() or s.split('-')

_ = use the previous variable that we been using 

join: joins a split string into one string again
'-'.join(_)

strip: removes outside whitespace 
_.strip()

help: get help with a certain definition
help(_)

find: searches for substrings, returns -1 if not there
_.find("-")

substring: a piece inside a string, character by character

slice: taking a piece of a string or list
_[start:stop]
start is inclusive, stop is not
strides: skipping every other how many
_[start:stop:step]
if step is negative, it will start from the end and go backwards
_[len(s)-1] the last character, aka _[-1]

open(<filename>,<mode>)
f = open("my_file.txt", 'w')
f.close() always close your file when you're done with it
    'w' is for write, will create a new file or overwrite an existing file
        f.write("text\n moretext")
        print("text\n moretext", file=f)
        \n is for newline within a string
    'r' is for read, can only read existing files
        f.read() reads the whole file in one string
        f.readline() reads one line
        f.readlines() reads a list of lines or all the lines in a with
        with a loop: 1 line per iteration.
    'a' is for append, will add onto an existing file 
with: automatically closes at end of block 
with open("my_file.txt", "w")

loops: iterate over iteratable things
for loop- a set number of iterations
for line in f:
    print(line, end='')
while loop- will go until false
while True:
    line = f.readline()
    if line == '':
        break
    print(line, end='')


zip: combines lists into a list of tuples
list(zip(list_1), list_2))
if you zip by itself it gives you zip obj at whatever location, you have to typecast into a list

typecasting: making one variable into another type of variable, must be compatible
a= "1"
int(a)

print: prints (obv)
    file=   writes to a specific file
    sep=    uses this as a separator
    end=    use this instead of newline
f-strings: formmatting outputs
print(f"this is the context for {x} variable")

a += b (edits the same list) can be different than a = a + b (creates a new list)
concatenation

operator.itemgetter: creates a key function for you. idk look it up 
I think it goes back to sorting
composite key: sorts by returning a tuple 
operator.itemgetter(1,0)

None: what to return if your function gets a dead end
called a destructive mutator
Bool False: equivalent to 0, "", [], and None
Bool True: equivalent to 1, "_", [_], and not None
and: checks for a false 
or: checks for a true
!=: not equal to
==: is equal to 
aliasing: two identifiers pointing to the same object
first = _,  second = first
copy: will have a new variable with same info in a different location
third = first.copy()
is: tests for the same object 
not: uno reverse card, aka ! (is not tests for different object)

comprehension: generating an iterable from another iterable
[expression for variable in expression2 if condition]
i.e. [sq for sq in sqares if sq %2==0]
confusing but more consise 
i.e. [(x,y) for x in set1 for y in set2 if x!=b if y<3] 
dict comprehension: creating dictionaries- constructs pairs
{expression><input sequence><optional condition}
i.e. {x:y for x,y in zip(keys,values)} or dict(zip(keys,values))

lazy iterators (generator expressions) data is generated when called, not defined,
 ^can iterate through them or call with next (range(_) is a generator)
next: will give you the next generated object from a generator
g = (2*n for n in range(1,11))
print(g)
<generator object <genexpr> at 0x103ea2050>
print(next(g))
2

open and similar calls don't do things themselves, they call upon operating system language
high-level language(python) is more user-friendly, low-level language is more machine friendly

ASCII - characters in a string (just a shape)
{x*1.06:.2f} .2f is 2 decimal places, 2 floating points
del deletes things
del _ 

size tells you how big a file is
width, height = image.size 


commands:
ls :shows us all the files in the current folder
pwd :shows us the full path 
. .. :one step up in file folders

----------

Classes and Objects
all object- oriented systems use class 

ADT - Abstract Data Type 
    stack (fuse) data types to create new data types 

s = "I am a string"
print(type(s))
<class str> string is the class, the variable is the object

something you do to the variable is called a method 
s.__add__("!") 
    the double _ (dender) is a convention for simple methods (not required)
    add is a built- in method to the string class, adds to the string
s.__sizeof__() - tells you how much memory that obj uses
s.startswith("I") - tells you t/f if it starts with that string 
print(dir(str)) will give you all the methods available for the string class
will also give you stuff for copy and such that are imported

Class: a collection of data and actions that can modify the data. Classes
    make data less abstract and they act as a blueprint for individual objects 
    ie the instructions to make a tree or an animal, if building a forest
Object: are constructed according to the blueprint that is the class.
    the specific object that takes up space and is an instance of a class. 
Instance: Another way to refer to a specific object
Instantiation: creating an instance of an object 

creating a class:
class Student:
    pass 

best_student = Student()
best_student.first_name = "Cossette"
best_student.last_name = "Gomez"

adding methods to classes:
    __init__ is the built in function to construct classes (the constructors)
class Actor:
    """Define"""
    def __init__(self):
        self.first_name = "Helen"
        self.last_name = "Mirren"

helen = Actor() - the parentheses automatically call the dender init __init__ 
print(f"{helen.first_name} is an actress")

or you can add attributes as parameters that you pass through the class 

    def __init__(self, firstname, lastname, etc)
        self.first_name = firstname 
        self.last_name = lastname 

helen = Actor("Helen", "Mirren")

you can add default parameters to classes as well, 
however default parameters must always come after all the required parameters

the def __init__ must always have self as the first parameter 


class attributes are defined above the init for object attributes. 
theyre delcared like normal variables but manifest as an attribute the same for every variable 
they can be altered for an individual object by doing 
    instance.class_attribute = "whatever"

for an unchangable attribute- class attribute
for an optionally changeable attribute- optional parameter in init__ 
for a unique to every object attribute- normal parameter in init__ 

forget what you put in a class? no worries just use 
    print(help(<class_name>)) 

class Actor:
    """Define the actor class"""
    union = "Screen Actors Guild"
    def __init__

you can also change a class attribute after the fact, but that will change it for all instances of the class
    class Student:
    """lol """
    boob = "yes"
    def __init__(self, grade="A"):
        self.grade_ = grade
    noob = "no"

    best_student = Student()
    best_student.first_name = "Cossette"
    best_student.last_name = "Gomez"

    Student.noob = "maybe"

    ok_student = Student()

    print(best_student.first_name, best_student.noob)
    print(ok_student.noob)


Shallow vs Deep copies

a shallow copy gives another name to the same variable 
    a = Actor()
    a.name = "billy joe"
    b = a 

a deep copy creates a new instance with the same attributes as the first 
    import copy 

    a = Actor()
    a.name = "billy joe"
    b = copy.deepcopy(a)
    

Changing Objects with Method 

Instance Methods
create a instance method by adding a function after the __init__ function within the method
then call the method by using instance_name.method_name()
    class Player:
        """Simple player class"""
        def __init__(self, health=100, score=0, level=1):
            self.health = health
            self.score = score
            self.level = level
            self.powerups = []
        
        def print_player(self):
            if self.health <=0:
                print("dead lol")
            else:
                print(self.health)

        def add_powerup(self, pu):
            self.powerups.append(pu)

    mario = Player() #the __init__ is called magically 
    mario.print_player()

both functions and methods can change something about an instance of a class 
Instance Methods always have self as the first parameter, whereas in functions the object is passes as a parameter
    def increase_level(player):
        player.level += 1
        print(f"You are at level {player.level}")

    increase_level(peach) 

Class Methods and Static Methods

class methods change something about the entire class, including every instance of the class
they are notated with the @classmethod decorator and take cls as the first parameter, 
then place in the same block as instance parameters 
    @classmethod
    def change_salary_cap(cls, new_cap):
        cls.salary_cap = new_cap
    
    NFLteam.change_salary_cap(199000000)

or you could do this but its not as good 
    class Student:
        """lol """
        boob = "yes"
        noob = "no"
    
    Student.noob = "maybe"

Alternate constructors: 
Factory Method:
having a method within the class that creates an instance with a common set of parameters
    @classmethod
    def method_name(cls):
        """"""
        return Class_name("the parameters you want)
    
    object = Class_name.method_name() 

Static Method:
creating a function that is specific to that class,
usually you can put an instance of itself in as a parameter, but has no required parameters
    @staticmethod
    def method_name(obj1, obj2):
        """"""
        return obj1.attribute += obj2.attribute
    
    x = Class_name.method_name(obj1, obj2) 
    y = obj1.method_name(obj1, obj2) 
both class and static methods can be called from either a class or an instance of a class, with the same result 

Functions:
not methods 
classes are mutable so you can pass stuff through parameters and do all kinds of stuff
    def print_player(p):
    """Print the status of a player"""
        if p.health <= 0:
            print(f"whatever")
        else:
            print(f"whatever.")

    print_player(player1)


basically
instance methods do stuff to an instance (singular)
class methods do stuff to the whole class
factory methods make instances 
static methods do something with an instance (plural)
functions can do all of the above, but outside the class declaration 



class Dinosaur:
  def __init__(self, size, weight):
    self.size = size
    self.weight = weight
    
class Carnivore:
  def __init__(self, diet):
    self.diet = diet
    
#bottom to top, left to right 
class Tyrannosaurus(Dinosaur, Carnivore):
  def __init__(self, size, weight, diet):
    Dinosaur.__init__(self, size, weight)
    Carnivore.__init__(self, diet)
    #pass the Tyrannosaurus self as a paramenter in the dinosaur and carnivore constructors 

    
tiny = Tyrannosaurus(12, 14, "whatever it wants")
#print(tiny.diet)


class A:
  def hello(self):
    print("Hello from A")

class B:
  def hello(self):
    print("Hello from B")

  def break_my_computer(self):
    print("Crazy? I was crazy once. They locked me in a room. A rubber room. A rubber room with rats. The rats make me crazy")
    B().break_my_computer()

class C(A, B):
  #overriding
  def hello(self):
    B().hello()
    #you do need the parentheses after B
    #overrides the hello() in A because A is the first inherited hello() function

  #extending
  def bonjour(self):
    print("Bonjour")

#multiple inheritance is debatable on whether on or not its a good design strategy
#some languages support it and some don't
obj = C()
obj.hello()
#super does not work with multiple inheritance because Python doesnt know what its referring to

#cohesion refers to how related data is to eachother
#classes increase cohesion
#multiple inheritences lower cohesion

#New Module: Encapsulation, Getters and Setters
#methods and data are encapsulated in their class - can be described by venn diagrams
#Python usually has no data restrictions - accessible from anywhere. Most languages don't allow this
#public = no restrictions 
#private = restricted 
class Phone:
    def __init__(self, model, megapixels, storage):
      self.model = model
      self._megapixels = megapixels
      #the underscore is a conventional way to notate a private variable in Python
      #it will not throw an error if you try to access it publicly tho
      self.__storage = storage
      #the dender makes it look like a private thing, it's just invisible to the outside 
      #for any dender the compiler adds the object name to it

    def helper(self):
      #use self.storage

    def __private_method(self):
        return "I am a private method"

my_phone = Phone("iPhone", 12)
print(my_phone.model)
print(my_phone._megapixels) 

# print(my_phone.__storage)
#throws an error that says it doesn't exist. 

print(my_phone.__private_method)
#throws an error because again the name changed 
print(my_phone._Phone__private_method)
#changed from name 

print(my_phone.__dict__)
#^useful function to show all the stuff declared in a class 

for all languages, there are getters and setters 
2 ways to use -property or get and set 

using methods is not the "python way" lol 

DATA VALIDATION
-------

polymorphism is when one call can call different things 
ie + is an integer adder and a string concatenator 

Magic Operators that can be polymorphed:
Operator	Method Name
+	object.__add__(self, other)
-	object.__sub__(self, other)
*	object.__mul__(self, other)
/	object.__truediv__(self, other)
//	object.__floordiv__(self, other)
<	object.__lt__(self, other)
<=	object.__le__(self, other)
==	object.__eq__(self, other)
!=	object.__ne__(self, other)
>	object.__gt__(self, other)
>=	object.__ge__(self, other)


from abc import ABC, abstractmethod

class Superclass(ABC):
    @abstractmethod
    def area(self): pass 

    @abstractmethod
    def perimeter(self): pass 

#an abstract class / method cannot be instantiated, it is only for using to build subclasses
class Subclass:
    def __init__(self, side):
        self.__side = side 

shape = Shape() #will not work 
sqaure = Subclass(4) #you can do this if you don't have any abstract methods

class Median:
  def average(self, num_1, num_2):
    return (num_1 + num_2)/2

  def calculate_median(self, num1, num2, num3=None, num4=None, num5=None): 
    if type(num5) == int:
      num_list = sorted([num1, num2, num3, num4, num5]) 
      return num_list[2]
    elif type(num4) == int:
      num_list = sorted([num1, num2, num3, num4]) 
      return self.average(num_list[1], num_list[2])
    elif type(num3) == int:
      num_list = sorted([num1, num2, num3]) 
      return num_list[1]
    elif type(num2) == int:
      return self.average(num1, num2)
    else:
      return "To find the median, input 2-5 integers"


m = Median()

print(m.calculate_median(3, 5, 1, 4, 2))
print(m.calculate_median(8, 6, 4, 2))	
print(m.calculate_median(9, 3, 7))
print(m.calculate_median(2, 5)) 

Unit Testing 

# calculator.py
class Calculator:
    def add(self, a, b):
        return a + b

    def subtract(self, a, b):
        return a - b

# test_calculator.py
import unittest
from calculator import Calculator

class TestCalculator(unittest.TestCase):
    def setUp(self):
        self.calc = Calculator()

    def test_add(self):
        self.assertEqual(self.calc.add(2, 3), 5)
        self.assertEqual(self.calc.add(-1, 1), 0)

    def test_subtract(self):
        self.assertEqual(self.calc.subtract(5, 3), 2)
        self.assertEqual(self.calc.subtract(3, 5), -2)

if __name__ == '__main__':
    unittest.main()

# calculator_doctest.py
class Calculator:
    def add(self, a, b):
        """
        Add two numbers.
        >>> calc = Calculator()
        >>> calc.add(2, 3)
        5
        >>> calc.add(-1, 1)
        0
        """
        return a + b

    def subtract(self, a, b):
        """
        Subtract two numbers.
        >>> calc = Calculator()
        >>> calc.subtract(5, 3)
        2
        >>> calc.subtract(3, 5)
        -2
        """
        return a - b

if __name__ == "__main__":
    import doctest
    doctest.testmod()
