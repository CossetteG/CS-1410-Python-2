ok python notes will go here

Review: 

string: "word" or 'words' or """lots
    of words"""
int: whole number
float: real number
bool: True or False




file: with open("filename.py", "r,w,a"):
    do stuff with the file: readline, writeline, for loop

list: ["ordered", "mutable",]
tuples: ("immutable", "ordered")
sets: {"unordered", "mutable", "does not allow duplicates}
dict: {"key": "value", "very": "fun", "unordered": "and mutable"} 
    aka lookup table,  hashtable, map

append: adds to the end of a list
_.append("element")
extend: adds a list to the end of another list
_.extend(other list) or you can add with +
insert: inserts and element in a specific place in a list
_.insert(index, element)
pop: _.pop() or _.pop(index) returns the value that is removed from the list
in: checks if something is in a list, returns true or false
for n in (): ..... if n in (): 
index: returns an elements position or an error if not found
_.index(n) 
sort: will rearrange a list to be in alphabetical order, must be one data type
_.sort() will return None and then sort the original list
sorted(): kinda the same as sort but better for creating new lists
sorted(_, key=_) 

^most are illegal for immutables: tuples, sets, dict
finding things in a dict: find by key only 
dict_name["key"]
get: finding things but with a default value in case it isnt there 
dict_name.get(key, default_value)
pop: for dict- input is the key, return is the value, and it will be deleted
pop(key, default=) default is optional in case its not there
to print all the values: for key in dict_name: print key, grades[key]
return key-value pairs: list(dict_name.items())
return keys: list(dict_name.keys())
return values: list(dict_name.values())
len: finds the length of an iterable, starts the count at 1
len(iterable)
clear: removes all the keys in a dict idk
adding to a dict with a loop: dict_name[key] = value
    dict_name.get(key, default value) + 1 #counts how many of that key is in the original list

Sets are like dicts but keys and values are 1 and allows set operations and no duplicates
Union: |, intersection &, and difference -- 
x,y = {'a','b','c'}, {'c','d','e’}
print(x | y)
{'d', 'e', 'b', 'c', 'a’}
print(x & y)
{'c’}
print(x – y)
{'a', 'b’}
print(y – x)
{'e', 'd’}
x |= {'f',’g’}
print(x)
{'f', 'g', 'b', 'c', 'a'}


split: takes every word in a string and turns it into a list of words
s.split() or s.split('-')

_ = use the previous variable that we been using 

join: joins a split string into one string again
'-'.join(_)

strip: removes outside whitespace 
_.strip()

help: get help with a certain definition
help(_)

find: searches for substrings, returns -1 if not there
_.find("-")

substring: a piece inside a string, character by character

slice: taking a piece of a string or list
_[start:stop]
start is inclusive, stop is not
strides: skipping every other how many
_[start:stop:step]
if step is negative, it will start from the end and go backwards
_[len(s)-1] the last character, aka _[-1]

open(<filename>,<mode>)
f = open("my_file.txt", 'w')
f.close() always close your file when you're done with it
    'w' is for write, will create a new file or overwrite an existing file
        f.write("text\n moretext")
        print("text\n moretext", file=f)
        \n is for newline within a string
    'r' is for read, can only read existing files
        f.read() reads the whole file in one string
        f.readline() reads one line
        f.readlines() reads a list of lines or all the lines in a with
        with a loop: 1 line per iteration.
    'a' is for append, will add onto an existing file 
with: automatically closes at end of block 
with open("my_file.txt", "w")

loops: iterate over iteratable things
for loop- a set number of iterations
for line in f:
    print(line, end='')
while loop- will go until false
while True:
    line = f.readline()
    if line == '':
        break
    print(line, end='')


zip: combines lists into a list of tuples
list(zip(list_1), list_2))
if you zip by itself it gives you zip obj at whatever location, you have to typecast into a list

typecasting: making one variable into another type of variable, must be compatible
a= "1"
int(a)

print: prints (obv)
    file=   writes to a specific file
    sep=    uses this as a separator
    end=    use this instead of newline
f-strings: formmatting outputs
print(f"this is the context for {x} variable")

a += b (edits the same list) can be different than a = a + b (creates a new list)
concatenation

operator.itemgetter: creates a key function for you. idk look it up 
I think it goes back to sorting
composite key: sorts by returning a tuple 
operator.itemgetter(1,0)

None: what to return if your function gets a dead end
called a destructive mutator
Bool False: equivalent to 0, "", [], and None
Bool True: equivalent to 1, "_", [_], and not None
and: checks for a false 
or: checks for a true
!=: not equal to
==: is equal to 
aliasing: two identifiers pointing to the same object
first = _,  second = first
copy: will have a new variable with same info in a different location
third = first.copy()
is: tests for the same object 
not: uno reverse card, aka ! (is not tests for different object)

comprehension: generating an iterable from another iterable
[expression for variable in expression2 if condition]
i.e. [sq for sq in sqares if sq %2==0]
confusing but more consise 
i.e. [(x,y) for x in set1 for y in set2 if x!=b if y<3] 
dict comprehension: creating dictionaries- constructs pairs
{expression><input sequence><optional condition}
i.e. {x:y for x,y in zip(keys,values)} or dict(zip(keys,values))

lazy iterators (generator expressions) data is generated when called, not defined,
 ^can iterate through them or call with next (range(_) is a generator)
next: will give you the next generated object from a generator
g = (2*n for n in range(1,11))
print(g)
<generator object <genexpr> at 0x103ea2050>
print(next(g))
2

open and similar calls don't do things themselves, they call upon operating system language
high-level language(python) is more user-friendly, low-level language is more machine friendly

ASCII - characters in a string (just a shape)
{x*1.06:.2f} .2f is 2 decimal places, 2 floating points
del deletes things
del _ 

size tells you how big a file is
width, height = image.size 

----------

commands:
ls :shows us all the files in the current folder
pwd :shows us the full path 
. .. :one step up in file folders


